<?php
// $Id$

/**
 * @file
 * The Sticky Notes module file.
 *
 * Sticky Notes provides the well known yellow sticky notes for drupal sites.
 * The can be attached to specific pages, all pages or all possible pages that
 * can be accessed using the same menu path as the current page.
 */

define('STICKY_NOTES_SCOPE_ALL', 'all');
define('STICKY_NOTES_SCOPE_LINK_PATTERN', 'patter');
define('STICKY_NOTES_SCOPE_LINK_PATH', 'path');

define('STICKY_NOTES_PRIORITY_LOW', 0);
define('STICKY_NOTES_PRIORITY_NORMAL', 1);
define('STICKY_NOTES_PRIORITY_HIGH', 2);

define('STICKY_NOTES_DEFAULT_ZINDEX', 50);
define('STICKY_NOTES_DEFAULT_SHOW_ON_ADMIN', 0);
define('STICKY_NOTES_DEFAULT_PRIORITY', STICKY_NOTES_PRIORITY_NORMAL);
define('STICKY_NOTES_DEFAULT_SCOPE', STICKY_NOTES_SCOPE_LINK_PATH);

/**
 * Implementation of hook_help().
 */
function sticky_notes_help($path, $arg) {
  switch ($path) {
    case 'admin/help#sticky_notes':
      return '<p>'. t('This module provides sticky notes for Drupal site.') .'</p>';
  }
}



/**
 * Implementation of hook_menu().
 *
 * @return void
 * @author Ralf Baumbach
 */
function sticky_notes_menu() {
  
  $items = array();
  
  // specific sticky notes callbacks
  $items['sticky-notes/load'] = array(
    'page callback' => 'js_sticky_notes_load',
    'access arguments' => array('view sticky notes'),
    'type' => MENU_CALLBACK,
    'file' => 'sticky_notes.callbacks.inc'
  );
  
  $items['sticky-notes/count'] = array(
    'page callback' => 'js_sticky_notes_page_count',
    'access arguments' => array('view sticky notes'),
    'type' => MENU_CALLBACK,
    'file' => 'sticky_notes.callbacks.inc'
  );
  
  $items['sticky-notes/save-position/%node/%/%'] = array(
    'page callback' => 'js_sticky_notes_save_position',
    'page arguments' => array(2, 3, 4),
    'access arguments' => array('view sticky notes'),
    'type' => MENU_CALLBACK,
    'file' => 'sticky_notes.callbacks.inc'
  );
  
  // administration pages
  $items['admin/settings/sticky_notes'] = array(
    'title' => 'Sticky Notes',
    'description' => 'Set preferences for sticky notes.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('sticky_notes_admin_form'),
    'access arguments' => array('administer sticky notes'),
    'file' => 'sticky_notes.admin.inc'
  );
  
  return $items;
}

/**
 * Implementation of hook_access().
 *
 * @return void
 * @author Ralf Baumbach
 */
 
function sticky_notes_access($op, $node, $account) {
  
  if (user_access('administer sticky notes')) {
    return TRUE;
  }
  
  switch ($op) {
    
    case 'create':
      return user_access('create sticky notes', $account);
      break;
    
    case 'update':
      if (user_access('edit all sticky notes', $account)) {
        return TRUE;
      }
      return (user_access('edit own sticky notes', $account) && ($account->uid == $node->uid));
      break;
    
    case 'delete':
      if (user_access('delete all sticky notes', $account)) {
        return TRUE;
      }
      return (user_access('delete own sticky notes', $account) && ($account->uid == $node->uid));
      break;
    
    case 'view':
      return (user_access('view sticky notes', $account));
      break;
    
  }
  
  return FALSE;
  
}

/**
 * Implementation of hook_node_info().
 *
 * @return void
 * @author Ralf Baumbach
 */
 
function sticky_notes_node_info() {
  
  $types = array();
  $types['sticky_notes'] = array(
    'name' => t('Sticky Note'),
    'module' => 'sticky_notes',
    'description' => t('A Sticky Note is a note with text, position and access rights that you can attach to every page on your site. You can leave messages for other People you are working with or remind yourself for things that are still to do.'),
    'has_title' => FALSE,
    'has_body' => TRUE,
    'body_label' => t('Note'),
    'locked' => TRUE
  );
  return $types;
}

/**
 * Implementation of hook_perm().
 *
 * @return void
 * @author Ralf Baumbach
 */
 
function sticky_notes_perm() {
  return array(
    'view sticky notes',
    'administer sticky notes',
    'create sticky notes',
    'edit all sticky notes',
    'edit own sticky notes',
    'delete all sticky notes',
    'delete own sticky notes',
  );
}

/**
 * Implementation of hook_theme().
 *
 * @return void
 * @author Ralf Baumbach
 */

function sticky_notes_theme() {
  return array(
    'sticky_notes_wrapper' => array(
      'template' => 'sticky-notes-wrapper',
      'arguments' => array('items' => NULL),
      'path' => drupal_get_path('module', 'sticky_notes') . '/templates',
    ),
    'sticky_notes_add_button' => array(
      'template' => 'sticky-notes-add-button',
      'arguments' => array('link' => NULL),
      'path' => drupal_get_path('module', 'sticky_notes') . '/templates',
    ),
    'sticky_notes_note' => array(
      'template' => 'sticky-notes-note',
      'arguments' => array('node' => NULL),
      'path' => drupal_get_path('module', 'sticky_notes') . '/templates',
    ),
  );
}

/**
 * Implementation of hook_load().
 *
 * @param string $node 
 * 
 * @return void
 * @author Ralf Baumbach
 */

function sticky_notes_load($node) {
  $additions = db_fetch_object(db_query('SELECT * FROM {node_sticky_note} WHERE vid = %d', $node->vid));
  return $additions;
}

/**
 * Load a sticky node by path
 *
 * @param string $path 
 * @param string $href 
 * 
 * @return void
 * @author Ralf Baumbach
 */

function sticky_notes_load_by_path($pattern = NULL, $path = NULL) {
  
  if ($pattern === NULL || $path === NULL) {
    
    $menu_item = menu_get_item();
    
    if ($pattern === NULL) {
      $pattern = $menu_item['path'];
    }
    
    if ($path === NULL) {
      $path = $menu_item['href'];
    }
    
  }
  
  $nodes = array();
  $result = db_query('SELECT nid FROM {node_sticky_note} WHERE link_path = "%s" OR (link_scope = "pattern" AND link_pattern = "%s") OR (link_scope = "all") ORDER BY position_z', $path, $pattern);
  $zIndex = variable_get('sticky_notes_minimal_zindex', STICKY_NOTES_DEFAULT_ZINDEX);
  while ($row = db_fetch_object($result)) {
    $node = node_load($row->nid);
    $node->position_z = $zIndex++;
    $nodes[] = $node;
  }
  return $nodes;
}

/**
 * Implementation of hook_insert().
 *
 * @param string $node 
 * 
 * @return void
 * @author Ralf Baumbach
 */

function sticky_notes_insert($node) {
  
  // setting default position for new sticky notes
  // one day this could be configurable via the admin section
  $node->position_x = 400;
  $node->position_y = 300;
  $node->position_z = sticky_notes_reorder_page_notes($node->link_path, $node->link_pattern);
  drupal_write_record('node_sticky_note', $node);
}

/**
 * Implementation of hook_update().
 *
 * @param string $node 
 *
 * @return void
 * @author Ralf Baumbach
 */

function sticky_notes_update($node) {
  if ($node->link_scope_old && $node->link_scope == -1) {
    $node->link_scope = $node->link_scope_old;
  }
  drupal_write_record('node_sticky_note', $node, array('nid'));
}

/**
 * Implementation of hook_delete().
 *
 * @param string $node 
 *
 * @return void
 * @author Ralf Baumbach
 */

function sticky_notes_delete($node) {
  db_query('DELETE FROM {node_sticky_note} WHERE nid = %d', $node->nid);
}

/**
 * Reorder all sticky notes for the given path or path pattern
 *
 * @param string $path 
 * @param string $pattern 
 *
 * @return int
 *  The last attributed z-index value of the concerned sticky notes
 *
 * @author Ralf Baumbach
 */

function sticky_notes_reorder_page_notes($path, $pattern) {
  $zIndex = variable_get('sticky_notes_minimal_zindex', STICKY_NOTES_DEFAULT_ZINDEX);
  $result = db_query('SELECT nid FROM {node_sticky_note} WHERE link_path = "%s" OR (link_scope = "pattern" AND link_pattern = "%s") ORDER BY position_z', $path, $pattern);
  while ($row = db_fetch_object($result)) {
    db_query('UPDATE {node_sticky_note} SET position_z = %d WHERE nid = %d', $zIndex++, $row->nid);
  }
  return $zIndex;
}

/**
 * Implementation of hook_form().
 *
 * @param object $node
 * 
 * @return void
 * @author Ralf Baumbach
 * @ingroup forms
 * @see sticky_notes_form_alter()
 */

function sticky_notes_form(&$node) {
  
  $type = node_get_types('type', $node);
  
  $form = array();
  
  $form['body_field'] = node_body_field($node, $type->body_label, $type->min_word_count);
  
  $form['body_field']['format']['#access'] = FALSE;
  $form['body_field']['teaser_include']['#access'] = FALSE;
  $form['body_field']['body']['#rows'] = 5;
  $form['body_field']['body']['#cols'] = 20;
  
  $form['link_pattern'] = array(
    '#type' => 'hidden',
    '#value' => $_REQUEST['pattern'],
  );
  
  $form['link_path'] = array(
    '#type' => 'hidden',
    '#value' => $_REQUEST['path'],
  );
  
  $form['priority'] = array(
    '#type' => 'select',
    '#title' => t('Priority'),
    '#options' => sticky_notes_get_priority_array(),
    '#default_value' => $node->nid ? $node->priority : STICKY_NOTES_DEFAULT_PRIORITY,
    '#prefix' => '<div class="sticky-notes-edit-form-additional">',
    '#suffix' => '</div>',
  );
  
  $scope_options = array(
    STICKY_NOTES_SCOPE_ALL => t('On all pages'),
    STICKY_NOTES_SCOPE_LINK_PATTERN => t('On all pages of this type (!hint)', array('!hint' => $_REQUEST['pattern'])),
    STICKY_NOTES_SCOPE_LINK_PATH => t('Only on the current page (!hint)', array('!hint' => $_REQUEST['path'])),
  );
  if ($node->nid && $node->link_scope && $node->link_scope != STICKY_NOTES_SCOPE_ALL) {
    $scope_options[-1] = t('Keep original setting (!hint)', array('!hint' => $node->{'link_' . $node->link_scope}));
    // keep the old scope stored
    $form['link_scope_old'] = array(
      '#type' => 'hidden',
      '#value' => $node->link_scope,
    );
  }
  
  if ($_REQUEST['pattern'] == $_REQUEST['path']) {
    unset($scope_options[STICKY_NOTES_SCOPE_LINK_PATTERN]);
  }
  
  $form['link_scope'] = array(
    '#type' => 'radios',
    '#title' => t('Visibility'),
    '#default_value' => $scope_options[-1] ? -1 : ($node->link_scope ? $node->link_scope : STICKY_NOTES_SCOPE_LINK_PATH),
    '#options' => $scope_options,
  );
  
  return $form;
  
}

/**
 * Implementation of hook_form_alter().
 *
 * @return void
 *
 * @author Ralf Baumbach
 * @see sticky_notes_form()
 */

function sticky_notes_form_alter(&$form, &$form_state, $form_id) {
  
  if ($form_id == 'sticky_notes_node_form') {
    
    global $user;
    
    // don't disable the following form elements, otherwise the form will
    // simply not submit
    $exclude = array(
      'form_build_id',
      'form_token',
      'form_id',
      'body_field',
      'link_scope',
      'priority',
      'buttons',
    );
    
    // disable most of the standard form elements
    _sticky_notes_disable_form_elements($form, $exclude);
    
    // and re-enable only what we really need
    $form['buttons']['preview']['#access'] = FALSE;
    $form['buttons']['delete']['#access'] = FALSE;
    
    // add a wrapper for styling
    $form['#prefix'] = '<div id="sticky-notes-form">';
    $form['#suffix'] = '</div>';
    
    // add a wrapper for th ebuttons as well
    $form['buttons']['#prefix'] = '<div class="sticky-notes-form-buttons">';
    $form['buttons']['#suffix'] = '</div>';
  }
  
}

/**
 * Retrieves an array of currently available priority states.
 *
 * @return void
 * @author Ralf Baumbach
 */

function sticky_notes_get_priority_array() {
  return array(
    STICKY_NOTES_PRIORITY_LOW => t('low'),
    STICKY_NOTES_PRIORITY_NORMAL => t('normal'),
    STICKY_NOTES_PRIORITY_HIGH => t('high'),
  );
}

/**
 * Implementation of hook_popups().
 *
 * @return void
 * @author Ralf Baumbach
 */

function sticky_notes_popups() {
  
  return array(
    '*' => array( // all pages.
      'a[href~=/node/add/sticky-notes]'  => array(  // add sticky note
        'noUpdate' => TRUE,
        'updateMethod' => 'none',
        'doneTest' => 'node/*',
        'noMessage' => TRUE
      ),
    ),
  );
}

/**
 * Disable the forms elements recursively.
 *
 * @param array $form 
 *
 * @param array $exclude 
 *  Keys of elements that should not be disabled
 *
 * @return void
 * @author Ralf Baumbach
 */

function _sticky_notes_disable_form_elements(&$form, $exclude) {
  
  if (is_array($form)) {
    foreach ($form as $key => $element) {
      if (is_array($form[$key]) && !in_array($key, $exclude)) {
        if (strpos($key, '#') === FALSE) {
          $form[$key]['#access'] = FALSE;
        }
        _sticky_notes_disable_form_elements($form[$key], $exclude);
      }
    }
  }
}

/**
 * Implementation of hook_init().
 *
 * @return void
 * @author Ralf Baumbach
 */

function sticky_notes_init() {
  
  if (user_access('view sticky notes') || user_access('administer sticky notes')) {
    
    // return if configured to not show on admin pages
    if (arg(0) == 'admin' && !variable_get('sticky_notes_show_on_admin', STICKY_NOTES_DEFAULT_SHOW_ON_ADMIN)) {
      return;
    }
    
    // add css
    drupal_add_css(drupal_get_path('module', 'sticky_notes') . '/css/sticky_notes.css');
  
    // add javascript
    drupal_add_js(drupal_get_path('module', 'sticky_notes') . '/js/sticky_notes.js');
    drupal_add_js(drupal_get_path('module', 'sticky_notes') . '/js/jquery-ui.min.js');
  
    // set some javascript values
    $menu_item = menu_get_item();
    drupal_add_js(array('sticky_notes' => array(
      'current_pattern' => urlencode($menu_item['path']),
      'current_path' => urlencode($menu_item['href']),
    )), 'setting');
  }
  
}

/**
 * Implementation of hook_preprocess_page().
 *
 * @param array $vars 
 * @return void
 * @author Ralf Baumbach
 */

function sticky_notes_preprocess_page(&$vars) {
  if (user_access('create sticky notes') || user_access('administer sticky notes')) {
    
    if (arg(0) == 'admin' && !variable_get('sticky_notes_show_on_admin', STICKY_NOTES_DEFAULT_SHOW_ON_ADMIN)) {
      return;
    }
    
    $menu_item = menu_get_item();
    $link = url('node/add/sticky-notes', array('query' => array('pattern' => $menu_item['path'], 'path' => $menu_item['href'])));
    $vars['header'] .= theme('sticky_notes_add_button', $link);
  }
}

/**
 * Implementation of hook_preprocess().
 *
 * @param array $vars 
 * @param string $hook 
 * @return void
 * @author Ralf Baumbach
 */

function sticky_notes_preprocess(&$vars, $hook) {
  if ($hook == 'sticky_notes_note') {
    global $user;
    
    $vars['content'] = check_markup($vars['node']->body);
    $vars['author'] = check_plain($vars['node']->name);
    $vars['note_can_be_modified'] = sticky_notes_access('update', $vars['node'], $user);
    $vars['note_can_be_deleted'] = sticky_notes_access('delete', $vars['node'], $user);
  }
}

/**
 * Implementation of hook_views_api().
 *
 * @return void
 * @author Ralf Baumbach
 */

function sticky_notes_views_api() {
  return array(
    'api' => 2,
    'path' => drupal_get_path('module', 'sticky_notes') . '/views',
  );
}
